# CTF-PWNME
## RSAMadness
Source code du chall :
```python
from Crypto.Util.number import *

flag = bytes_to_long(open('flag.txt', 'rb').read())

factors = [getPrime(32) for i in range(32)]

n = 1

for factor in factors:
    n *= factor

e = 2**16+1

c = pow(flag, e, n)

out = open('output.txt', 'w')
out.write(f'{n = }\n')
out.write(f'{e = }\n')
out.write(f'{c = }\n')
out.close()
```

Output : 

    n = 7119541149326911263846237336068827035426390978903518184071800577216994524551352495493081918851614130414331517984836350572442636378573029918244826773120934619489882189716217950746021474614776218719283095363211027209022463670918163108226484066350208938841262463820714679754689007199511102068228362022891339
    e = 65537
    c = 2677813284789904126438760381359441846563302259269282617284434686954175401256426228859726004471829287478436507358546887844300713181475644091802430738029057414949633797451370298947353237612172383915668526623229664084518635473132876673558581857332713891368639409620521533432667125874667705549410188263908117

Pour ce chall le RSA qu'on a est un RSA multiple prime donc on va factoriser n pour obtenir tous petits les nombres premiers qui le compose
Grâce à https://factordb.com on a la liste des nombres premiers qui nous servirons pour caser RSA: 

    2198644891,2251025417,2357822911,2423999881,2470236277,2540464159,2640483821,2666729449,2823253471,2838669527,2865747971,2899467931,2988954343,3003972773,3172761587,3246135349,3316767901,3359522891,3437669927,3458545777,3478381031,3557092417,3559422193,3560174803,3560322977,3632401841,3681108461,3788558861,3886443779,3890200829,4036970099,4045097149

On doit donc calculer tous les inverses modulaires de e

Calculer les inverses du produit des premiers avec le dernier premier du produit

Calculer la liste des c**d mod p où d est un inverse et p le premier de ce "mini" RSA

Enfin faire quelques opérations et ça deviendrait le bordel si j'essaye d'expliquer et on congru le tout modulo n

Les algos sont plus rapides que nous pour ce genre de calcul du coup :
```python
from Crypto.Util.number import *

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

n = 7119541149326911263846237336068827035426390978903518184071800577216994524551352495493081918851614130414331517984836350572442636378573029918244826773120934619489882189716217950746021474614776218719283095363211027209022463670918163108226484066350208938841262463820714679754689007199511102068228362022891339
e = 65537
c = 2677813284789904126438760381359441846563302259269282617284434686954175401256426228859726004471829287478436507358546887844300713181475644091802430738029057414949633797451370298947353237612172383915668526623229664084518635473132876673558581857332713891368639409620521533432667125874667705549410188263908117

primes = [2198644891,2251025417,2357822911,2423999881,2470236277,2540464159,2640483821,2666729449,2823253471,2838669527,2865747971,2899467931,2988954343,3003972773,3172761587,3246135349,3316767901,3359522891,3437669927,3458545777,3478381031,3557092417,3559422193,3560174803,3560322977,3632401841,3681108461,3788558861,3886443779,3890200829,4036970099,4045097149]

d = [modinv(e, i-1) for i in primes]
p = primes[0]

t = []
for i in range(1, len(primes)):
   t.append(modinv(p, primes[i]))
   p *= primes[i]

x = [pow(c, d[i], primes[i]) for i in range(len(primes))]
p = primes[0]

for i in range(1, len(primes)):
   x[0] += p * ((x[i] - x[0])*t[i-1] % primes[i])
   p *= primes[i]


print(long_to_bytes(x[0]%n))
```

El famoso flag : PWNME{f02368945726d5fc2a14eb576f7276c0c}
